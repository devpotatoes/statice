((global,factory)=>{if((typeof exports==="object")&&(typeof module!=="undefined")){module.exports=factory()}else if((typeof define==="function")&&(define.amd===true)){define(factory)}else{global=global||self;global.wco=factory()}})(this,()=>{const wco={};let config={wcoPath:undefined,schemasPath:undefined,cacheLimit:0};let cache={map:new Map(),get:(key)=>{if(cache.map.has(key)===false){return undefined};const value=cache.map.get(key);cache.map.delete(key);cache.map.set(key,value);return value},set:(key,value)=>{if(cache.map.has(key)===true){cache.map.delete(key)}else if((config.cacheLimit>0)&&(cache.map.size>=config.cacheLimit)){cache.map.delete(cache.map.keys().next().value)};cache.map.set(key,value)},clear:()=>{cache.map.clear()}};function checkFileExtension(path,extension){if(path.split(".").pop()===extension){return true}else{return false}};async function getComponent(path){if((path!==undefined)&&(checkFileExtension(path,"wco")===true)){try{const res=await fetch(path);if(res.ok===true){return res.text()}else{throw new Error(`[wco][ERROR] Component file not found: "${ path }". The requested .wco file is missing or the path is incorrect.`)}}catch(err){throw new Error(`[wco][ERROR] Failed to fetch component file: "${ path }". Network error or permission issue.`)}}else{throw new Error(`[wco][ERROR] Invalid component file type: "${ path }". Expected a .wco file.`)}};async function getSchema(path){if((path!==undefined)&&(checkFileExtension(path,"json")===true)){try{const res=await fetch(path);if(res.ok===true){return res.text().then(text=>{try{return JSON.parse(text)}catch(err){throw new Error(`[wco][ERROR] Invalid JSON format in schema file: "${ path }". The file could not be parsed.`)}})}else{throw new Error(`[wco][ERROR] Schema file not found: "${ path }". The requested .json file is missing or the path is incorrect.`)}}catch(err){throw new Error(`[wco][ERROR] Failed to fetch schema file: "${ path }". Network error or permission issue.`)}}else{throw new Error(`[wco][ERROR] Invalid schema file type: "${ path }". Expected a .json file.`)}};function parseComponent(component){const regex=/\$\{wco\("([^"]+)"(?:,\s*"([^"]+)")?(?:,\s*(\$\{.*?\}|\{.*?\}))?\)\}|\$\{([a-zA-Z0-9_.]+)\}/g;let varsArray=[...component.matchAll(regex)];varsArray=varsArray.map(varExpr=>{if(varExpr[1]){return{type:"wco",wcoPath:varExpr[1],schemaPath:varExpr[2]||undefined,varExpr:varExpr[3]||undefined}}else if(varExpr[4]){return{type:"var",name:varExpr[4]}}else{throw new Error(`[wco][ERROR] Invalid variable expression format in component: "${ varExpr }". The expression could not be parsed or is not supported.`)}});return varsArray};function checkValueType(value,type){if(type==="any"){return true};if((type==="char")&&(typeof value==="string")&&(value.length===1)){return true};if((type==="str")&&(typeof value==="string")){return true};if((type==="int")&&(Number.isInteger(value)===true)&&(isFinite(value)===true)){return true};if((type==="int16")&&(Number.isInteger(value)===true)&&(value>=-32768)&&(value<=32767)){return true};if((type==="uint16")&&(Number.isInteger(value)===true)&&(value>=0)&&(value<=65535)){return true};if((type==="int32")&&(Number.isInteger(value)===true)&&(value>=-2147483648)&&(value<=2147483647)){return true};if((type==="uint32")&&(Number.isInteger(value)===true)&&(value>=0)&&(value<=4294967295)){return true};if((type==="float32")&&(typeof value==="number")&&(Math.abs(value)<=3.4e38)){return true};if((type==="float64")&&(typeof value==="number")&&(Math.abs(value)<=1.8e308)){return true};if((type==="bool")&&(typeof value==="boolean")){return true};return false};function matchSchema(schema,value){if(checkValueType(value,schema.type)===false){return false};if((schema.match!==undefined)&&(schema.match.regex!=="")){const regex=new RegExp(schema.match.regex);if(regex.test(value)===false){return false}};if((schema.match!==undefined)&&(schema.match.enum.length>0)){if(schema.match.enum.includes(value)===false){return false}};if((schema.match!==undefined)&&(schema.match.length!==undefined)&&(schema.type==="str")){if((schema.match.length.min!==undefined)&&(value.length<schema.match.length.min)){return false};if((schema.match.length.max!==undefined)&&(value.length>schema.match.length.max)){return false}};if((schema.match!==undefined)&&(schema.match.range!==undefined)&&(typeof value==="number")&&(isFinite(value)===true)){if((schema.match.range.min!==undefined)&&(value<schema.match.range.min)){return false};if((schema.match.range.max!==undefined)&&(value>schema.match.range.max)){return false}};return true};function escapeHtml(value){if(typeof value!=="string"){return value};return value.replace(/[&<>"]/g,(tag)=>{const chars={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;","`":"&#x60;","=":"&#x3D;"};return chars[tag]||tag})};function swapVar(component,type,name,value){value=escapeHtml(value);if(type==="var"){const regex=new RegExp(`\\$\\{${ name }\\}`,"g");return component.replace(regex,value)}else if(type==="wco"){const regex=new RegExp(`\\$\\{wco\\("${ name }"(?:,\\s*"${varObj.schemaPath }")?\\)\\}`,"g");return component.replace(regex,value)}};wco.clearCache=()=>{cache.clear()};wco.getConfig=()=>{return{wcoPath:config.wcoPath,schemasPath:config.schemasPath,cacheLimit:config.cacheLimit}};wco.setConfig=(configObj)=>{config={wcoPath:configObj.wcoPath||config.wcoPath,schemasPath:configObj.schemasPath||config.schemasPath,cacheLimit:configObj.cacheLimit||config.cacheLimit}};wco.render=async(wcoPath,schemaPath=undefined,valuesObj=undefined)=>{let component=undefined;let schema=undefined;let varsArray=[];const fullPath=`${window.location.pathname.substring(0,window.location.pathname.lastIndexOf("/"))}/${ wcoPath }`;const cachedData=cache.get(fullPath);if(cachedData===undefined){component=await getComponent(wcoPath);schema=await getSchema(schemaPath);varsArray=parseComponent(component);cache.set(fullPath,{component:component,schema:schema,varsArray:varsArray})}else{component=cachedData.component;schema=cachedData.schema;varsArray=cachedData.varsArray};for(const varObj of varsArray){if(varObj.type==="var"){const value=varObj.name.split(".").reduce((index,key)=>index&&index[key],valuesObj);if(value!==undefined){if((schema!==undefined)&&(schema[varObj.name]!==undefined)){if(matchSchema(schema[varObj.name],value)===true){component=swapVar(component,varObj.type,varObj.name,value)}else{if(schema[varObj.name].default!==undefined){component=swapVar(component,varObj.type,varObj.name,schema[varObj.name].default)}else{console.warn(`[wco][WARNING] Variable ${varObj.name } does not match the specified schema, and no default value is set.`)}}}else{component=swapVar(component,varObj.type,varObj.name,value)}}else{if((schema!==undefined)&&(schema[varObj.name]!==undefined)){if(schema[varObj.name].required===true){if(schema[varObj.name].default!==undefined){component=swapVar(component,varObj.type,varObj.name,schema[varObj.name].default)}else{console.warn(`[wco][WARNING] Variable ${varObj.name } does not match the specified schema, and no default value is set.`)}}else{component=swapVar(component,varObj.type,varObj.name,"")}}else{component=swapVar(component,varObj.type,varObj.name,"")}}}else if(varObj.type==="wco"){const regex=/\$\{wco\((.*?)\)\}/g;function getPathFromSubComponent(wcoPath,subComponentRelativePath){const parentDir=wcoPath.substring(0,wcoPath.lastIndexOf("/")+1);if(subComponentRelativePath.startsWith("/")===true){return subComponentRelativePath};if(parentDir.endsWith("/")===true){return parentDir+subComponentRelativePath};return parentDir+"/"+subComponentRelativePath};subComponentPath=getPathFromSubComponent(wcoPath,varObj.wcoPath);let renderedSubComponent;if(varObj.varExpr!==undefined){const match=varObj.varExpr.match(/^\$\{([a-zA-Z0-9_.]+)\}$/);subComponentSchemaPath=getPathFromSubComponent(wcoPath,varObj.schemaPath)||undefined;if(match!==null){renderedSubComponent=await wco.render(subComponentPath,subComponentSchemaPath,valuesObj[match[1]])}else{throw new Error(`[wco][ERROR] Invalid variable expression format in component: "${varObj.varExpr }". The expression could not be parsed or is not supported.`)}}else{renderedSubComponent=await wco.render(subComponentPath)};component=component.replace(regex,renderedSubComponent)}};return component};return wco});